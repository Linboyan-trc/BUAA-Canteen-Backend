# 依次执行build,test, deploy
stages:
  - build
  - test
  - deploy

# 6. 生产构建
# 6.1 当生产人员在测试服9101端口测试通过后，测试者发起新的合并请求
# 6.2 项目管理人把developing分支合并到master分支
# 6.3 然后构建新的镜像
# 7. 合并测试
# 7.1 然后会进行pylint测试
# 第6和第7步其实和开发者提出合并申请所触发的CI完全一样，管理者来转门负责合并到master是为了部署到生产服
build_production:
  stage: build
  only:
    - master
  tags:
    - machine001
  script:
    - docker build -t "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID" .

# 3. 合并构建
# 3.1 运维把代码合并到developing分支，developing分支得到新的合并后自动触发
# 3.2 gitlab会让服务器上的gitlan-runner进程构建新的镜像
# 4. 合并测试
# 4.1 然后会进行pylint测试
# 第3和第4步其实和开发者提出合并申请所触发的CI完全一样，运维来转门负责合并到developing是为了部署到测试服
build_develop:
  stage: build
  only:
    - developing
  tags:
    - machine001
  script:
    - docker build -t "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID" .

# 1. 正式合并前构建
# 1.1 当发生合并请求的时候，在正式合并之前会根据项目下的Dockerfile构建一次
# 1.2 具体就是gitlab平台去告诉machine001这个运行了gitlab runner的docker进程应该开始针对合并请求构建了
# 1.3 具体操作是创建一个docker镜像，镜像名称根据ci_pipelie_id来确定
build_merge_requests:
  stage: build
  only:
    refs:
      - merge_requests
  tags:
    - machine001
  script:
    - docker build -t "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID" .

# 2. 正式合并前测试
# 2.1 当发生合并请求的时候，在正式合并之前会测试
# 2.2 已经构建好了docker镜像，现在在docker容器中运行这个构建好的镜像
# 2.3 设置这个容器在停止运行之后会自动删除，然后指定容器中运行的镜像
# 2.4 然后在容器内部将容器内部的config.example.yaml为config.yaml文件，其实就是多一个一模一样的文件只是改个文件名
# 2.5 接着在容器内部运行pylint检查代码，只检查core模块和judge模块
# 2.6 这个容器已经在运行Django项目，并且连接了数据库，等待外界和这个容器通信
# 2.7 合并请求阶段只有pylint的检查，不会进行真正的测试
# 2.8 执行完pylint之后容器会自动停止，之后自动删除
test_all:
  stage: test
  only:
    - master
    - developing
    - merge_requests
  tags:
    - machine001
  script:
    - docker run --rm=true "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID" /bin/bash -c "cp config.example.yaml config.yaml"

# 7. 生产服部署
# 7.1 当管理者合并到master分支后，会自动停止上一个生产服的docker容器并删除
# 7.2 然后新建一个长期运行的、名字一样的容器
# 7.3 挂载配置文件
# 7.4 然后容器映射到宿主机的8100端口
# 7.5 然后前端自动访问80端口
deploy_production:
  stage: deploy
  only:
    - master
  tags:
    - machine001
  script:
    - docker stop buaa-canteen-backend-production && docker rm buaa-canteen-backend-production || true
    - docker run --restart=unless-stopped --name=buaa-canteen-backend-production -v /mnt/data/app-config/config-production.yaml:/app/config.yaml -d -p 8100:8000 "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID"

# 5. 测试服部署
# 5.1 当运维合并到developing分支后，会自动停止上一个测试服的docker容器并删除
# 5.2 然后新建一个长期运行的、名字一样的容器
# 5.3 然后把主机上的配置文件挂载到容器的/app/config.yaml下，这样可以从容器外部修改配置文件
# 5.3 因此测试服的配置文件不向开发者暴露，只有测试人员知道，只保留在服务器上；不过在目前为了方便开发人员自行测试，开发人员也可以在开发机连接测试服
# 5.4 容器后台运行
# 5.5 容器映射到宿主机的9100端口
# 5.6 运维的工作就是在gitlab上同意合并，然后测试服的代码得到更新，运维人员在测试服上9100开始测试后端
# 5.6 而前端在9101端口，实际上是通过"http://cscore.buaa.edu.cn:9101"来进行测试
deploy_develop:
  stage: deploy
  only:
    - developing
  tags:
    - machine001
  script:
    - docker stop buaa-canteen-backend-developing && docker rm buaa-canteen-backend-developing || true
    - docker run --restart=unless-stopped --name=buaa-canteen-backend-developing -v /mnt/data/app-config/config-developing.yaml:/app/config.yaml -d -p 9100:8000 "buaa-canteen-backend:ci_job_$CI_PIPELINE_ID"
